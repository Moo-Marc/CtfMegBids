function [res4Info, DateBug] = Bids_ctf_read_res4(res4Path, isQuiet)

% Oct 26, 2017: created - meets the requirements of MEG-BIDS v1
% Elizabeth Bock
%
% 2019-03-08: Adjusted SensorDesc, units, output filter info, removed null
% characters from date/time fields. (Should probably remove in all text
% fields.)
%  Marc Lalancette

if nargin < 2 || isempty(isQuiet)
    isQuiet = false;
end

% ===== INTIALIZATIONS ======
% Define constants
MAX_COILS = 8;
MAX_AVERAGE_BINS = 8;
SensorTypes ={...
    'MEGREFMAG',...         % 0  Reference magnetometer channel          (Set to 5002 to use the definition in coil_def.dat)
    'MEGREFGRADAXIAL' ,...  % 1  Reference 1st-order gradiometer channel (Set to 5003 or 5004 to use the definition in coil_def.dat)
    'MEGREFGRADAXIAL2',...  % 2  Reference 2nd-order gradiometer channel
    'MEGREFGRADAXIAL3',...  % 3  Reference 3rd-order gradiometer channel
    'MEGMAG' ,...           % 4  Sensor magnetometer channel located in head shell
    'MEGGRADAXIAL',...      % 5  Sensor 1st-order gradiometer channel located in head shell
    'MEGGRADAXIAL2' ,...    % 6  Sensor 2nd-order gradiometer channel located in head shell
    'MEGGRADAXIAL3',...     % 7  Sensor 3rd-order gradiometer channel located in head shell
    'EEGREF',...            % 8  EEG unipolar sensors not on the scalp
    'EEG',...               % 9  EEG unipolar sensors on the scalp
    'OTHER',...             % 10 ADC input current 
    'TRIG',...              % 11 Stimulus channel for MEG41
    'OTHER',...             % 12 Value recorded from a SONY Video time output ('hhmmssff')
    'HLU',...               % 13 Measured position of head and head coils
    'DAC',...               % 14 DAC channel from ECC or HLU
    'OTHER',...             % 15 SAM channel derived through data analysis
    'OTHER',...             % 16 Virtual channel derived by combining two or more physical channels
    'SYSCLOCK',...          % 17 System clock (integer counter incremented at 12kHz)
    'ADC',...               % 18 ADC channels from ECC
    'TRIG', ...             % 19 Analog trigger channels
    'TRIG', ...             % 20 Digital trigger channels
    'EEG', ...              % 21 EEG bipolar sensor not on the scalp
    'EEG', ...              % 22 EEG ADC over range flags
    'OTHER', ...            % 23 MEG resets (counts sensor jumps for crosstalk purposes)
    'OTHER ', ...           % 24 Dipole source
    'OTHER', ...            % 25 Normalized SAM channel derived through data analysis
    'OTHER', ...            % 26 Orientation of head localization field
    'OTHER', ...            % 27 Extracted signal from each sensor of field generated by each localization coil
    'FITERR', ...           % 28 Fit error from each head localization coil
    'OTHER', ...            % 29 Any other type of sensor not mentioned but still valid
    'OTHER', ...            % 30 Invalid
    'VEOG', ...             % 31 VEOG, typically recorded as type 21
    'HEOG', ...             % 32 HEOG, typically recorded as type 21
    'ECG', ...              % 33 ECG, typically recorded as type 21
    'EMG', ...              % 34 EMG, typically recorded as type 21
    'EOG', ...              % 35 EOG, typically recorded as type 21
    };

SensorDesc ={...
    'Reference magnetometer channel', ...
    'Reference 1st-order gradiometer channel', ...
    'Reference 2nd-order gradiometer channel', ...
    'Reference 3rd-order gradiometer channel', ...
    'Sensor magnetometer channel located in head shell', ...
    'Sensor 1st-order gradiometer channel located in head shell', ...
    'Sensor 2nd-order gradiometer channel located in head shell', ...
    'Sensor 3rd-order gradiometer channel located in head shell', ...
    'EEG unipolar sensors not on the scalp', ...
    'EEG unipolar sensors on the scalp', ...
    'ADC input current', ...
    'Stimulus markers', ...
    'Value recorded from a SONY Video time output (''hhmmssff'')', ...
    'Measured position of head and head coils', ...
    'DAC channel from ECC or HLU', ...
    'SAM channel derived through data analysis', ...
    'Virtual channel derived by combining two or more physical channels', ...
    'System clock (integer counter incremented at 12kHz)', ...
    'ADC channels from ECC', ...
    'Analog trigger channel', ...
    'Digital trigger channel', ...
    'EEG bipolar sensor not on the scalp', ...
    'EEG ADC over range flags', ...
    'MEG resets (counts sensor jumps for crosstalk purposes)', ...
    'Dipole source', ...
    'Normalized SAM channel derived through data analysis', ...
    'Orientation of head localization field', ...
    'Extracted signal from each sensor of field generated by each localization coil', ...
    'Fit error from each head localization coil', ...
    'Any other type of sensor not mentioned but still valid', ...
    'Invalid', ...
    'Vertical EOG', ...
    'Horizontal EOG', ...
    'ECG', ...
    'EMG', ...
    'EOG'};

SensorUnit = {...
    'T',...         % 0  Reference magnetometer channel          (Set to 5002 to use the definition in coil_def.dat)
    'T' ,...  % 1  Reference 1st-order gradiometer channel (Set to 5003 or 5004 to use the definition in coil_def.dat)
    'T',...  % 2  Reference 2nd-order gradiometer channel
    'T',...  % 3  Reference 3rd-order gradiometer channel
    'T' ,...           % 4  Sensor magnetometer channel located in head shell
    'T',...      % 5  Sensor 1st-order gradiometer channel located in head shell
    'T' ,...    % 6  Sensor 2nd-order gradiometer channel located in head shell
    'T',...     % 7  Sensor 3rd-order gradiometer channel located in head shell
    'V',...            % 8  EEG unipolar sensors not on the scalp
    'V',...               % 9  EEG unipolar sensors on the scalp
    'A',...             % 10 ADC input current
    'V',...              % 11 Stimulus channel for MEG41
    's',...             % 12 Value recorded from a SONY Video time output ('hhmmssff')
    'm',...               % 13 Measured position of head and head coils
    'V',...               % 14 DAC channel from ECC or HLU
    'n/a',...             % 15 SAM channel derived through data analysis
    'V',...             % 16 Virtual channel derived by combining two or more physical channels
    's',...          % 17 System clock (integer counter incremented at 12kHz)
    'V',...               % 18 ADC channels from ECC
    'V', ...             % 19 Analog trigger channels
    'V', ...             % 20 Digital trigger channels
    'V', ...              % 21 EEG bipolar sensor not on the scalp
    'V', ...              % 22 EEG ADC over range flags
    'n/a', ...            % 23 MEG resets (counts sensor jumps for crosstalk purposes)
    'n/a', ...           % 24 Dipole source
    'n/a', ...            % 25 Normalized SAM channel derived through data analysis
    'n/a', ...            % 26 Orientation of head localization field
    'n/a', ...            % 27 Extracted signal from each sensor of field generated by each localization coil
    '%', ...           % 28 Fit error from each head localization coil
    'n/a', ...            % 29 Any other type of sensor not mentioned but still valid
    'n/a', ...            % 30 Invalid
    'V', ...             % 31 VEOG, typically recorded as type 21
    'V', ...             % 32 HEOG, typically recorded as type 21
    'V', ...              % 33 ECG, typically recorded as type 21
    'V', ...              % 34 EMG, typically recorded as type 21
    'V', ...              % 35 EOG, typically recorded as type 21
    };    

%% ===== READING .RES4 FILE =====
% Open file (Big-endian byte ordering)
% [fid,message] = fopen(res4_file, 'rb', 's');
[fid,message] = fopen(res4Path, 'rb', 'b');
if fid < 0
    error([message, ' %s'], res4Path);
end


% Read HEADER
hdr = fread(fid,8,'char')';

% Read nfSetUp
res4.appName         = char(fread(fid,256,'char')');
res4.dataOrigin      = char(fread(fid,256,'char')');
res4.dataDescription = char(fread(fid,256,'char')');
res4.no_trials_avgd  =      fread(fid,  1,'int16')';
res4.data_time       = strrep(char(fread(fid,255,'char')'), char(0), '');
res4.data_date       = strrep(char(fread(fid,255,'char')'), char(0), '');
DateBug = false;
if isempty(res4.data_date)
    if ~isQuiet
        warning('No acquisition date/time.  Probably a tuning dataset.');
    end
    res4.data_date = '01-Jan-1900';
    res4.data_time = '00:00';
    DateBug = true;
elseif numel(res4.data_date) < 10
    if ~isQuiet
        warning('Acq date/time bug.  This dataset should be fixed.');
    end
    % Rare strange Acq bug: "locked" dataset (Acq probably crashed) with
    % inverted date and time fields and different format!
    tempdate = res4.data_time;
    res4.data_time = res4.data_date;
    res4.data_date = datestr(datetime(tempdate, 'InputFormat', 'dd/MM/uuuu'), 'dd-mmm-yyyy');
    DateBug = true;
elseif isequal(res4.data_date(1:2), '00')
    if ~isQuiet
        warning('Acq day zero bug.');
    end
    % New software can output date as 00-Jan-1900, which is invalid.
    res4.data_date(1:2) = '01';
    DateBug = true;
end

gSetUp.no_samples  = fread(fid,1,'int32')';
gSetUp.no_channels = fread(fid,1,'int16')';
fseek(fid, ceil(ftell(fid)/8)*8, -1);
gSetUp.sample_rate = fread(fid,1,'double')';
fseek(fid, ceil(ftell(fid)/8)*8, -1);
gSetUp.epoch_time  = fread(fid,1,'double')';
gSetUp.no_trials   = fread(fid,1,'int16')';
fseek(fid, ceil(ftell(fid)/4)*4, -1);
gSetUp.preTrigPts  = fread(fid,1,'int32')';
gSetUp.no_trials_done = fread(fid,1,'int16')';
gSetUp.no_trials_display = fread(fid,1,'int16')';
fseek(fid, ceil(ftell(fid)/4)*4, -1);
gSetUp.save_trials         = fread(fid,1,'int32')';
gSetUp.primaryTrigger      = char(fread(fid,1,'uchar')');
gSetUp.secondaryTrigger    = char(fread(fid,MAX_AVERAGE_BINS,'uchar')');
gSetUp.triggerPolarityMask = char(fread(fid,1,'uchar')');

gSetUp.trigger_mode = fread(fid,1,'int16')';
fseek(fid, ceil(ftell(fid)/4)*4, -1);
gSetUp.accept_reject_Flag = fread(fid,1,'int32')';
gSetUp.run_time_display = (fread(fid,1,'int16')');
fseek(fid, ceil(ftell(fid)/4)*4, -1);
gSetUp.zero_Head_Flag = fread(fid,1,'int32')';
fseek(fid, ceil(ftell(fid)/4)*4, -1);
gSetUp.artifact_mode = fread(fid,1,'int32')';
gSetUp.padding = fread(fid,1,'int32')';

nfSetUp.nf_run_name           = char(fread(fid, 32,'char')');
nfSetUp.nf_run_title          = char(fread(fid,256,'char')');
nfSetUp.nf_instruments        = char(fread(fid, 32,'char')');
nfSetUp.nf_collect_descriptor = char(fread(fid, 32,'char')');
nfSetUp.nf_subject_id         = char(fread(fid, 32,'char')');
nfSetUp.nf_operator           = char(fread(fid, 32,'char')');
% prevent out of range character conversion warning
tmp = fread(fid,60,'char')';
tmp(tmp<0) = 0;
nfSetUp.nf_sensorFileName = tmp;

fseek(fid,ceil(ftell(fid)/4)*4,-1);
nfSetUp.rdlen = fread(fid,1,'int32')';


%% ===== READ FILTERS =====
fseek(fid,1844,-1);
% Run Description
res4.rdesc = fread(fid,nfSetUp.rdlen,'*char');
% Filters
classType = {'CLASSERROR','BUTTERWORTH','','',''};
filtType  = {'TYPERROR','LOWPASS','HIGHPASS','NOTCH','','',''};
% Number of filters
no_filters = fread(fid,1,'int16');
% Read all filters
[filter(1:no_filters)] = struct('freq',[],'fClass',[],'fType',[],'numParam',[],'params',[]);
for fi = 1:no_filters
    filter(fi).freq     = fread(fid,1,'double');
    % Filter class
    iClass = fread(fid,1,'int32') + 1;
    if (iClass <= length(classType))
        filter(fi).fClass = classType{iClass};
    else
        filter(fi).fClass = 'UNKNOWN';
    end
    % Filter type
    iType = fread(fid,1,'int32') + 1;
    if (iType <= length(filtType))
        filter(fi).fType = filtType{iType};
    else
        filter(fi).fType = 'UNKNOWN';
    end
    % Parameters
    filter(fi).numParam = fread(fid,1,'int16');
    filter(fi).params   = fread(fid,filter(fi).numParam,'double');
end

%% ===== READ COILS INFORMATION =====
% Channel names
channel_names = cell(1,gSetUp.no_channels);
channel_names_short = cell(1,gSetUp.no_channels);
for chan = 1:gSetUp.no_channels
    tmp = fread(fid,32,'uchar')';
    tmp = char(tmp);
    tmp(tmp>127) = 0;
    channel_names{chan}       = strtok(tmp,char(0));
    channel_names_short{chan} = char(strtok(channel_names{chan},'-'));
end

% Sensor types
CoilType = {'CIRCULAR','SQUARE','???'};
% Read description of all sensors
SensorRes(gSetUp.no_channels) = struct();
for chan = 1:gSetUp.no_channels
    SensorRes(chan).sensorTypeIndex = fread(fid,1,'int16');
    SensorRes(chan).originalRunNum = fread(fid,1,'int16');
    
    id = fread(fid,1,'int32')+1;
    if isempty(id)
        id = -1;
    end
    if (id > 3) || (id <0)
        id = 3;
    end
    
    SensorRes(chan).coilShape  = CoilType{id};
    SensorRes(chan).properGain = fread(fid,1,'double');
    SensorRes(chan).qGain      = fread(fid,1,'double');
    SensorRes(chan).ioGain     = fread(fid,1,'double');
    SensorRes(chan).ioOffset   = fread(fid,1,'double');
    SensorRes(chan).numCoils   = fread(fid,1,'int16');
    SensorRes(chan).grad_order_no = fread(fid,1,'int16');
    SensorRes(chan).stimPolarity = fread(fid,1,'int32'); % 4.2 format
    
    for coil = 1:MAX_COILS
        SensorRes(chan).coilTbl(coil).position.x = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).position.y = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).position.z = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).position.junk = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).orient.x = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).orient.y = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).orient.z = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).orient.junk = fread(fid,1,'double');
        SensorRes(chan).coilTbl(coil).numturns = fread(fid,1,'int16');
        padding = fread(fid,1,'int32'); %#ok<*NASGU> 
        padding = fread(fid,1,'int16');
        SensorRes(chan).coilTbl(coil).area = fread(fid,1,'double');
    end
    
    for coil = 1:MAX_COILS
        SensorRes(chan).HdcoilTbl(coil).position.x = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).position.y = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).position.z = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).position.junk = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).orient.x = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).orient.y = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).orient.z = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).orient.junk = fread(fid,1,'double');
        SensorRes(chan).HdcoilTbl(coil).numturns = fread(fid,1,'int16');
        padding = fread(fid,1,'int32');
        padding = fread(fid,1,'int16');
        SensorRes(chan).HdcoilTbl(coil).area = fread(fid,1,'double');
    end
end

% Close file
fclose(fid);

res4Info.SensorTypes = SensorTypes;
res4Info.SensorRes = SensorRes;
res4Info.SensorDesc = SensorDesc;
res4Info.SensorUnit = SensorUnit;
res4Info.channel_names = channel_names;
res4Info.gSetUp = gSetUp;
res4Info.res4 = res4;
res4Info.filter = filter;